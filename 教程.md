# 从零开始读懂 Memosyne：手把手老教师课程

> **写在前面**：这份教材专为“几乎什么都不懂”的同学准备。我会先把所有陌生词拆开，用生活化的比喻解释，再带你一步步拼装整个项目。读完以后，你应该可以按照费曼学习法——“先学会，再讲给别人听”——把这套项目教给同学。

---

## 第 0 章：先看全局，像搭乐高一样

- 目标：把一个简单的“英文单词 + 中文释义”的表格，加工成带音标、例句、标签等的学习卡片；同时把 Markdown 格式的测验题，转换成系统能读的标准答案文件。
- 方法：把项目拆成一层层的“积木”，每块积木只负责一件小事，就像做饭前先备好菜、锅、调味料。

> **费曼练习**：用自己的话描述“输入”和“输出”分别长什么样，再讲给朋友听。

---

## 第 1 章：把专业名词翻译成日常语言

| 术语 | 白话解释 | 项目中的例子 |
| --- | --- | --- |
| **配置层（Configuration Layer）** | 放所有“开关设置”的地方，好比家里电闸箱。你只在这里决定 API 密钥、默认模型、文件夹位置。 | [`src/memosyne/config/settings.py`](src/memosyne/config/settings.py) 里的 `Settings` 类就负责统一读取 `.env` 里的密钥、路径，并确保目录存在。【F:src/memosyne/config/settings.py†L17-L132】 |
| **核心抽象（Core Abstractions）** | 规定“别人必须会的招式”，像武馆里定的基本功。谁想加入，就得会这些动作。 | [`core/interfaces.py`](src/memosyne/core/interfaces.py) 里用 `LLMProvider` 协议规定“你至少得会 `complete_prompt` 和 `complete_structured` 这两招”。【F:src/memosyne/core/interfaces.py†L16-L82】 |
| **模型层（Models）** | 数据的“模具”。不管谁给的数据，都要先倒进模具检查形状对不对。 | [`models/term.py`](src/memosyne/models/term.py) 中的 `TermInput`, `LLMResponse`, `TermOutput` 会检查单词是不是空的、音标格式对不对。【F:src/memosyne/models/term.py†L14-L129】 |
| **Provider（提供者）** | 专门跟外界（OpenAI、Anthropic）打交道的“翻译官”。只改翻译官就能换一家服务。 | [`providers/openai_provider.py`](src/memosyne/providers/openai_provider.py) 负责把我们的请求发给 OpenAI，并把结果变成 JSON。【F:src/memosyne/providers/openai_provider.py†L1-L137】 |
| **服务层（Service Layer）** | 真正“做事”的部分，相当于厨师。它拿到材料（模型层数据），调用翻译官（Provider），完成业务。 | [`services/reanimater.py`](src/memosyne/services/reanimater.py) 的 `Reanimater.process()` 按顺序：调 LLM→验证→套业务规则→拼输出。【F:src/memosyne/services/reanimater.py†L13-L159】 |
| **CLI（Command Line Interface）命令行界面** | 在黑色终端里互动的小程序，就像自助点餐机。 | [`cli/reanimate.py`](src/memosyne/cli/reanimate.py) 会逐步问你模型、输入文件，帮你跑完整流程。【F:src/memosyne/cli/reanimate.py†L1-L152】 |
| **API（Application Programming Interface）程序接口** | 提供给别的 Python 程序调用的函数，就像“外卖接口”，别人只要传参数就能拿结果。 | [`api.py`](src/memosyne/api.py) 里的 `reanimate()` 和 `lithoform()` 就是两个可以直接调用的函数。【F:src/memosyne/api.py†L1-L120】 |
| **SOLID 原则** | 五条写程序的“防塌楼”守则。这里我们重点感受：单一职责（每个模块只干一件事）和依赖倒置（高层调用接口，不碰细节）。 | 例如 `Reanimater` 只关心“怎么处理术语”，不负责读写文件；读写交给仓库类 `CSVTermRepository`。【F:src/memosyne/services/reanimater.py†L33-L159】【F:src/memosyne/repositories/csv_repository.py†L33-L114】 |
| **结构化数据验证** | 让数据必须按固定格式出现，像进厂要量尺寸。格式不对立刻拒收，避免后面出错。 | `LLMResponse` 检查音标、词性、例句是否符合要求，不合格就抛错。【F:src/memosyne/models/term.py†L51-L118】 |
| **接口解耦** | 通过接口（比如 `LLMProvider`）把“使用者”和“实现者”分开，让他们互不影响。 | `Reanimater` 只依赖 `LLMProvider` 接口，因此换 OpenAI 或 Claude 只需要换一个对象。【F:src/memosyne/services/reanimater.py†L33-L78】【F:src/memosyne/core/interfaces.py†L16-L82】 |
| **Pydantic** | 一个“智能表格检查器”。你定义字段规则，它自动验证并给出清晰报错。 | `TermInput` 用 Pydantic 自动去空格、确保字段不为空，避免脏数据流入。【F:src/memosyne/models/term.py†L22-L43】 |
| **pandas** | 一个“电子表格超能力库”。适合批量处理表格数据。本项目里虽然核心逻辑用原生 CSV，但保留 pandas 以便扩展。 | `requirements.txt` 中列出了 `pandas`，提醒我们未来可以用它做更复杂的数据分析。【F:requirements.txt†L4-L12】 |
| **业务逻辑（Business Logic）** | 跟公司需求强相关的规则，比如“缩写词不能有音标”。放在服务层统一管理。 | `_apply_business_rules()` 函数清洗例句、补词性，就是业务逻辑的集中地。【F:src/memosyne/services/reanimater.py†L119-L159】 |

> **费曼练习**：挑两个名词，试着用“就像……一样”的比喻讲给朋友听。

---

## 第 2 章：搭建骨架 —— 目录就像厨房动线

```
src/memosyne/
├── config/        # 放电闸：全局设置
├── core/          # 武馆规则：接口/异常
├── models/        # 模具：输入、输出、LLM 响应
├── providers/     # 翻译官：OpenAI、Anthropic 封装
├── repositories/  # 仓库：读写 CSV、术语表
├── services/      # 厨师：Reanimater、Lithoformer
├── utils/         # 工具：批次号、日志、路径
├── cli/           # 自助点餐机：命令行入口
└── api.py         # 外卖接口：给别人调用
```

当你要新增功能，先问自己：“这属于哪一层？”答出来，就知道文件应该放哪儿。

---

## 第 3 章：配置层动手实践

1. 打开 `src/memosyne/config/settings.py`。
2. 观察 `Settings` 类：每个属性都带说明、默认值、校验规则。
3. `get_settings()` 会缓存实例，避免反复读 `.env`。这就像把路由器设置保存下来，后面随用随取。【F:src/memosyne/config/settings.py†L90-L159】
4. `ensure_dirs()` 自动创建输入/输出目录，让新手不必手动建文件夹。【F:src/memosyne/config/settings.py†L77-L89】

> **费曼练习**：向同学解释“为什么 `openai_api_key` 要求最小长度 20？如果少写字符会怎样？”

---

## 第 4 章：核心抽象的威力

- `LLMProvider`（Protocol）像“口试大纲”，规定必须回答哪几个问题，但不强制血统。【F:src/memosyne/core/interfaces.py†L16-L63】
- `BaseLLMProvider`（抽象基类）像“示范课”，提供默认初始化、检查配置。【F:src/memosyne/core/interfaces.py†L65-L109】
- 服务层只拿到这个接口对象，就能安心调用，而不用知道底层具体 SDK。

> **实战**：在 Python REPL 里写一个 `class MockLLM:`，只要实现同名方法，就可以被当成 `LLMProvider` 使用。文件底部已经给出示例，可照着练习。【F:src/memosyne/core/interfaces.py†L111-L154】

---

## 第 5 章：模型层 = 结构化数据验证现场

- `TermInput`：入口保安，过滤掉空行、纯中文单词。【F:src/memosyne/models/term.py†L14-L47】
- `LLMResponse`：验收 LLM 的答卷。音标不符合 `/.../` 格式、例句为空都会被拒绝。【F:src/memosyne/models/term.py†L51-L118】
- `TermOutput`：打包成 CSV 行，把 Memo ID、批次信息都装进去。【F:src/memosyne/models/term.py†L120-L171】

> **费曼练习**：解释为什么验证“缩写词不能有音标”是一种业务规则，而不是随便的限制。

---

## 第 6 章：Provider —— 换翻译官不改厨师

- `OpenAIProvider` 负责：准备提示词 → 请求 OpenAI → 把 JSON 回传 → 处理错误。如果温度参数不被支持，它会自动重试，避免任务中断。【F:src/memosyne/providers/openai_provider.py†L1-L137】
- `AnthropicProvider` 实现同样接口，只是底层换成 Claude。因为有统一抽象，`Reanimater` 无需关心差异。

> **费曼练习**：想象新增 “AzureOpenAIProvider”，你需要复制哪几个步骤？

---

## 第 7 章：仓库层 —— 专人管数据

- `CSVTermRepository.read_input()`：
  1. 自动识别逗号/分号/制表符；
  2. 支持多种表头别名（word/headword/词条等）；
  3. 读到的每行都丢进 `TermInput` 验证。【F:src/memosyne/repositories/csv_repository.py†L1-L88】
- `write_output()` 把 `TermOutput` 逐行写入 CSV，不带表头，保证格式统一。【F:src/memosyne/repositories/csv_repository.py†L90-L114】

这体现了 SOLID 里的“单一职责”：读写 CSV 的所有细节，都藏在仓库层，服务层无需重复写文件逻辑。

---

## 第 8 章：服务层 —— 把所有零件拼在一起

以 `Reanimater.process()` 为例，它做的事情有明确顺序：
1. **调用 LLM**：向 Provider 请求完整词条信息。【F:src/memosyne/services/reanimater.py†L84-L108】
2. **验证**：把 LLM 返回的数据放进 `LLMResponse` 模型，确保字段安全。
3. **业务规则**：
   - 短语强制改成 `P.`；
   - 例句重复定义会清空并给出日志；
   - 词根词缀统一小写、去多余空格。【F:src/memosyne/services/reanimater.py†L119-L159】
4. **标签映射**：根据英文标签找出对应的中文。
5. **生成 Memo ID & Batch 信息**：利用工具库保证编号连续、不重复。
6. **打包输出**：用 `TermOutput.from_input_and_llm()` 拼成最终行。

因为所有步骤都集中在这里，我们就能说“服务层负责业务逻辑”。

---

## 第 9 章：CLI vs API —— 给不同人用的两个入口

- **CLI**：适合不会写代码的人，照提示一步步输入信息。
  - 例子：`python -m memosyne.cli.reanimate`。
  - 功能：检查 API Key、提示模型选择、自动生成输出路径。【F:src/memosyne/cli/reanimate.py†L53-L152】
- **API**：给会写 Python 的人，直接在脚本里调用函数。
  - 例子：
    ```python
    from memosyne.api import reanimate
    result = reanimate("221.csv", start_memo_index=221)
    ```
  - `reanimate()` 会自动读 CSV、加载术语表、生成批次 ID、写结果，最后返回一份总结报告。【F:src/memosyne/api.py†L23-L120】

> **费曼练习**：讲给朋友听——“CLI 更像聊天机器人，API 更像自动贩卖机”。

---

## 第 10 章：utils 工具库（略举一例）

- `BatchIDGenerator` 用日期 + 运行次数 + 词条数组合出唯一批次号，避免文件互相覆盖。
- `unique_path()` 碰到重名文件，会自动加后缀 (1)、(2)。

这些工具让主流程保持干净，符合 SOLID 的“单一职责”。

---

## 第 11 章：把全部流程串起来

1. **准备配置**：在 `.env` 写入 `OPENAI_API_KEY=` 等密钥，`Settings` 会帮你读取并验证。
2. **准备输入**：把 `word, zh_def` 的 CSV 放到 `data/input/reanimater/`。
3. **运行 CLI 或调用 API**：
   - CLI 会问你模型、输入、批注；
   - API 直接传参数即可。
4. **服务层工作**：
   - 从仓库拿数据；
   - 调 Provider 调 LLM；
   - Pydantic 模型验证；
   - 应用业务逻辑；
   - 输出 CSV。
5. **检查结果**：`data/output/reanimater/` 下生成的新批次文件，打开即可看到完整卡片。

> **费曼练习**：尝试画一张流程图，从 CLI 输入开始，一直到写出 CSV，标出每一步用到了哪一层。

---

## 第 12 章：进一步练习

1. **口头复述**：
   - 什么是配置层？为什么 `Settings` 能保证目录存在？
   - `LLMProvider` 的存在让我们在哪些地方不用改代码？
2. **动手尝试**：
   - 新建一个假的 `MockLLMProvider`，返回固定 JSON，跑 `Reanimater` 看是否通过验证。
   - 修改 `TermInput` 的校验规则，让它拒绝包含数字的单词，观察报错信息。
3. **教给别人**：
   - 用“厨房比喻”讲一次整个架构。
   - 带同学实操一遍 CLI。

---

## 附录：快速对照表

| 我该做什么？ | 需要的文件/函数 |
| --- | --- |
| 修改默认模型、路径、批次规则 | `src/memosyne/config/settings.py`【F:src/memosyne/config/settings.py†L35-L89】 |
| 换 LLM 服务商 | 在 `providers/` 新增一个类，实现 `LLMProvider` 协议。【F:src/memosyne/core/interfaces.py†L16-L82】 |
| 增加 CSV 字段校验 | 改 `models/term.py` 里的 Pydantic 模型。【F:src/memosyne/models/term.py†L14-L171】 |
| 调整读写行为 | 修改 `repositories/csv_repository.py`。【F:src/memosyne/repositories/csv_repository.py†L33-L114】 |
| 修改业务规则 | 看 `services/reanimater.py` 的 `_apply_business_rules`。【F:src/memosyne/services/reanimater.py†L119-L159】 |
| 给非技术同学使用 | 直接运行 `python -m memosyne.cli.reanimate`。【F:src/memosyne/cli/reanimate.py†L1-L152】 |
| 在脚本中调用 | `from memosyne.api import reanimate`。【F:src/memosyne/api.py†L23-L120】 |

---

> **老教师提醒**：别急着记住所有词。每次学到一个新块，立刻说出“它像生活中的什么？为什么要这样设计？”。能说出来，就代表真的懂了。
